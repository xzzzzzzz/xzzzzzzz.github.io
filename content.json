{"meta":{"title":"沙漠中的勇者","subtitle":null,"description":null,"author":"xuzheng","url":"http://yoursite.com"},"pages":[{"title":"404","date":"2018-01-30T08:13:04.000Z","updated":"2018-01-30T08:13:04.000Z","comments":true,"path":"404/index.html","permalink":"http://yoursite.com/404/index.html","excerpt":"","text":""},{"title":"my-hexo","date":"2018-01-30T03:44:46.000Z","updated":"2018-01-30T03:44:47.000Z","comments":true,"path":"my-hexo/index.html","permalink":"http://yoursite.com/my-hexo/index.html","excerpt":"","text":""},{"title":"search","date":"2018-01-30T08:12:57.000Z","updated":"2018-01-30T08:12:57.000Z","comments":true,"path":"search/index.html","permalink":"http://yoursite.com/search/index.html","excerpt":"","text":""}],"posts":[{"title":"js简单的封装","slug":"js简单的封装","date":"2018-01-31T07:57:11.000Z","updated":"2018-01-31T08:08:10.000Z","comments":true,"path":"2018/01/31/js简单的封装/","link":"","permalink":"http://yoursite.com/2018/01/31/js简单的封装/","excerpt":"","text":"JS是一门面向对象语言,其对象是用prototype属性来模拟的。来看看如何封装JS对象. 常规封装123456789101112function Person (name,age,sex)&#123; this.name = name; this.age = age; this.sex = sex;&#125; Pserson.prototype = &#123; constructor:Person, sayHello:function()&#123; console.log(&apos;hello&apos;); &#125;&#125; 这种方式是比较常见的方式,比较直观,但是Person() 的职责是构造对象,如果把初始化的事情也放在里面完成,代码就会显得繁琐,如果放在一个方法里初始化会不会好点呢? 升级版 (常见)123456789101112131415function Person (info)&#123; this._init_(info);&#125; Pserson.prototype = &#123; constructor : Person, _init_ : function(info) &#123; this.name = info.name; this.age = info.age; this.sex = info.sex; &#125; sayHello:function()&#123; console.log(&apos;hello&apos;); &#125;&#125; 可是,说到这里就发现,name,age,sex 并没有在Person里面申明,哪来的呢??? new 的执行原理new 的执行过程可以用下面一个函数来代替 12345678910var myNew = function(constructor, args) &#123; var o = &#123;&#125;; o.__proto__ = constructor.prototype; var res = constructor.apply(o, args); var type = typeof res; if ([&apos;string&apos;, &apos;number&apos;, &apos;boolean&apos;, &apos;null&apos;, &apos;undefined&apos;].indexOf(type) !== -1) &#123; return o; &#125; return res;&#125; 解释:首先通过 var o = {} 构造一个空对象.然后将 构造函数的原型属性prototype赋值给o 的原型对象proto 。这样，在执行 this.init(info); 这句话的时候，对象 o 就可以在其原型对象中查找init 方法。（原型链）。之后这句话 就是精髓了。 1var res = constructor.apply(o,args); 以o为上下文调用函数，同时将参数作为数组传递。那么，1this._init_(info); 这句话就会被 o 执行，函数 12345_init_ : function(info) &#123; this.name = info.name; this.age = info.age; this.sex = info.sex; &#125; 以 o 为上下文调用，o也将拥有自己的 name,age,sex 属性。 如果在构造函数中，return 复合类型，包括对象，函数，和正则表达式，那么就会直接返回这个对象，否则，返回 o12345var type = typeof res; if([&apos;string&apos;,&apos;number&apos;,&apos;boolean&apos;,&apos;null&apos;,&apos;undefined&apos;].indexOf(type) !== -1)&#123; return o; &#125; return res; 测试一下123456789function Person(name) &#123; this.name = name; &#125; Person.prototype.sayHello = function() &#123; console.log(this.name); &#125; var o1 = myNew(Person, [&apos;pawn&apos;]); console.log(o1); o1.sayHello(); call方法:语法：call([thisObj[,arg1[, arg2[, [,.argN]]]]])定义：调用一个对象的一个方法，以另一个对象替换当前对象。说明：call 方法可以用来代替另一个对象调用一个方法。call 方法可将一个函数的对象上下文从初始的上下文改变为由 thisObj 指定的新对象。如果没有提供 thisObj 参数，那么 Global 对象被用作 thisObj。 apply方法：语法：apply([thisObj[,argArray]])定义：应用某一对象的一个方法，用另一个对象替换当前对象。说明：如果 argArray 不是一个有效的数组或者不是 arguments 对象，那么将导致一个 TypeError。如果没有提供 argArray 和 thisObj 任何一个参数，那么 Global 对象将被用作 thisObj， 并且无法被传递任何参数。 类jQuery 封装这种方式是我从 jQuery 那里学来的。 jQuery 对象具有很强的集成性，可以作为函数调用，也可以做为对象调用，当作为函数调用的时候，她可以无需 new 而返回它的一个实例，很方便。 代码1234567891011var Person = function(info)&#123; return new Person.prototype.init(info);&#125; Person.prototype = &#123; constructor: Person, init:function()&#123; this.name = info.name. &#125;&#125;Person.prototype.init.prototype = Person.prototype; 这种封装方式非常巧妙。将对象的构造操作放在函数的里面，而自己充当一个工厂。不断调用 prototype 并不是一个直观的做法，于是 12345678910111213141516171819var Person = function(info)&#123; return new Person.fn.init(info);&#125; Person.fn = Person.prototype = &#123; constructor: Person, init:function()&#123; this.name = info.name; this.sayHello = function()&#123; this.makeArray(); &#125; &#125; makeArray:function()&#123; console.log(this.name); &#125;&#125;// 这句话的作用// 虽然把makeArray 等常用方法挂载到 Person.prorotype 下面,但还是会被 init 这个实例使用.Person.fn.init.prototype = Person.fn; 最后用 闭包 封装起来 12345678910111213141516171819202122var Person = (function(window) &#123; var Person = function(name) &#123; return new Person.fn.init(name); &#125; Person.fn = Person.prototype = &#123; constructor: Person, init: function(name) &#123; this.name = name; this.sayHello = function() &#123; this.makeArray(); &#125; &#125;, makeArray: function() &#123; console.log(this.name); &#125; &#125; Person.fn.init.prototype = Person.fn; return Person; &#125;)(); 测试一下 123var p = Person(&apos;pawn&apos;); console.log(p); p.sayHello(); object.create()js也提供了一种构造对象的方式,object.create(); 可以传递一个对象Person,构造一个p,并且使p 继承Person.123456789var Person = &#123; name: &apos;pawn&apos;, sayHello: function() &#123; console.log(this.name); &#125; &#125; var p = Object.create(Person); console.log(p); p.sayHello(); 可以看到,对象Person的属性成为了p的原型属性,也就是说 p 原型继承自 Person ! 我们可以实现一个 Object.create()123456Object.create = function(prototype)&#123; function Func()&#123;&#125;; Func.prototype = prototype; var o = new Func(); return o;&#125; 在这里,我们将 Person 作为 构造函数的 原型属性,就可以构造出 以Person 为原型对象的对象.","categories":[],"tags":[]},{"title":"使用Hexo+Github一步步搭建属于自己的博客（基础）","slug":"使用Hexo-Github一步步搭建属于自己的博客（基础）","date":"2018-01-30T08:23:44.000Z","updated":"2018-01-30T09:23:26.000Z","comments":true,"path":"2018/01/30/使用Hexo-Github一步步搭建属于自己的博客（基础）/","link":"","permalink":"http://yoursite.com/2018/01/30/使用Hexo-Github一步步搭建属于自己的博客（基础）/","excerpt":"","text":"一、第一步：下载安装Git1、Git下载 2、安装步骤 让后一路默认 二、第二步：下载安装node.js 1、nodeJs下载地址 2、安装步骤：一路默认就行（安装路径根据自己需要更改） 三、第三步：安装hexo1、利用 npm 命令即可安装。在任意位置点击鼠标右键，选择Git Bash 2、2、输入命令：npm install -g hexo 这里如果地址被“墙”，可以参考 这篇文章的“安装Hexo”部分 四、第四步：初始化Hexo1、创建文件夹（我的是在E盘创建的Hexo） 2、在Hexo文件下，右键运行Git Bash，输入命令：hexo init 3、在_config.yml,进行基础配置 其中可以在这里 浏览更多主题，然后在Hexo文件夹下 Git Bash 输入命令：git clone https://github.com/iissnan/hexo-theme-nextthemes/next（next为主题名字），来获得更多主题 4、本地浏览博客 分别输入 如下命令： hexo g hexo s 这里有 更多hexo常用命令 在浏览器输入：localhost：4000 ，就可以进行访问，效果如下： 5、写文章 在E:\\Hexo\\source_posts文件下，新建.md文件就可以写文章 title: 我的博客 五、部署到Github上1、申请Github账号，（注意别忘了进行账号邮箱验证） 2.new repository 然后点击 3、在_config.yml进行配置 4、安装hexo-deployer-git自动部署发布工具 npm instal lhexo-deployer-git --save 5、发布到Github 输入如下命令：hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 6、测试访问 在浏览器输入：https://yanqiangmiffy.github.io/","categories":[],"tags":[]},{"title":"myHexo","slug":"myHexo","date":"2018-01-30T03:51:06.000Z","updated":"2018-01-30T05:35:18.000Z","comments":true,"path":"2018/01/30/myHexo/","link":"","permalink":"http://yoursite.com/2018/01/30/myHexo/","excerpt":"","text":"这是我的第一个博客 对对对 More info: 码云 你是谁啊","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2018-01-30T03:16:30.000Z","updated":"2018-01-30T03:25:34.000Z","comments":true,"path":"2018/01/30/hello-world/","link":"","permalink":"http://yoursite.com/2018/01/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"Hexo使用笔记","slug":"Hexo使用笔记","date":"2017-10-12T01:58:03.000Z","updated":"2018-01-30T07:23:55.000Z","comments":true,"path":"2017/10/12/Hexo使用笔记/","link":"","permalink":"http://yoursite.com/2017/10/12/Hexo使用笔记/","excerpt":"Hexo新建笔记12345678910111213npm install hexo -g //安装 npm update hexo -g //升级 hexo version //查看hexo的版本hexo init nodejs-hexo //创建nodejs-hexo 名字的本地文件hexo init nodejs-hexo //创建博客hexo init blog //初始化，生成文件夹为blogcd blog //进入blog文件夹npm install //安装依赖库hexo generate //生成一套静态网页hexo server //运行测试,浏览器打开地址，http://localhost:4000/hexo deploy //进行部署。hexo new &quot;new article&quot; //新建文章‘new article’","text":"Hexo新建笔记12345678910111213npm install hexo -g //安装 npm update hexo -g //升级 hexo version //查看hexo的版本hexo init nodejs-hexo //创建nodejs-hexo 名字的本地文件hexo init nodejs-hexo //创建博客hexo init blog //初始化，生成文件夹为blogcd blog //进入blog文件夹npm install //安装依赖库hexo generate //生成一套静态网页hexo server //运行测试,浏览器打开地址，http://localhost:4000/hexo deploy //进行部署。hexo new &quot;new article&quot; //新建文章‘new article’ 新建的笔记文件路径：source/_posts 目录下, new-article.md 的文件, 打开文件, 文件开头采用的是yaml格式，用三条短横线分隔。下面是文章正文，采用用的是markdown格式。 ####新建、删除或修改文章后，不需要重启hexo server，刷新一下即可预览。#### Hexo文章属性设置设置 描述 Defaultlayout Layout post或pagetitle 文章的标题date 创建日期 文件的创建日期updated 修改日期 文件的修改日期comments 是否开启评论 truetags 标签categories 分类permalink url中的名字 文件名 Hexo摘要1这里是文章的摘要部分&lt;!--more--&gt;后面才是文章的正文内容 layout如果你修改了layout，在scaffolds文件夹里一定要有名字对应的模版文件，否则会采用默认模版。 Hexo草稿草稿相当于很多博客都有的“私密文章”功能。1$ hexo new draft &quot;new draft&quot; 草稿会在source/_drafts目录下生成一个new-draft.md文件。但是这个文件不被显示在页面上，链接也访问不到。也就是说如果你想把某一篇文章移除显示，又不舍得删除，可以把它移动到_drafts目录之中。 如果你希望强行预览草稿，更改配置文件：1render_drafts: true 或者，如下方式启动预览：1$ hexo server --drafts 下面这条命令可以把草稿变成文章，或者页面：1$ hexo publish [layout] &lt;filename&gt; 找不到git部署ERROR Deployer not found: git解决方法：npm install hexo-deployer-git –save hexo更换皮肤 hexo官网选择皮肤: git clone 放到themes目录下 编辑文件_config.yml，找到theme一行，改成 theme: pacman 本地启动hexo服务器，打开浏览器 http://localhost:4000","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/categories/Hexo/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]}]}